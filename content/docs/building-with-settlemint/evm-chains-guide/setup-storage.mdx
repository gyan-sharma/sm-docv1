---
title: Setup Storage
description: Add S3 or IPFS storage
---

import { Tabs, Tab } from "fumadocs-ui/components/tabs";
import { Callout } from "fumadocs-ui/components/callout";
import { Steps } from "fumadocs-ui/components/steps";
import { Card } from "fumadocs-ui/components/card";

<div style={{
  backgroundColor: "#e1eafd", 
  color: "#356fee", 
  padding: "0.5px 10px 10px 10px",
  borderRadius: "10px", 
  fontSize: "18px", 
  fontWeight: "bold",
  lineHeight: "1.2",
  textAlign: "left"
}}>
  Summary  
  <div style={{ fontSize: "16px", fontWeight: "normal", marginTop: "5px" }}>
To build a blockchain application, the first step is setting up a blockchain network with the correct number of validating and non-validating nodes. You can either deploy a permissioned network such as Hyperledger Besu or GoQuorum, or connect to an L1 or L2 Public Network like Ethereum, Polygon PoS, Hedera, Polygon zkEVM, Avalanche, Arbitrum, or Optimism. Both mainnet and testnet versions are available for public networks.

When creating an application on SettleMint, you will be prompted to select a
network and assign it a name. By default, a first validating node is deployed
along with the network, and you must assign a name to it as well. You may
optionally provide an EC DSA P256 private key to use as custom key material for
the node identity. If no key is provided, SettleMint will generate one
automatically and save it in your private keys.

In SettleMint-managed (SaaS) mode, you will need to choose between a shared or
dedicated cluster for deployment. You can also select a cloud provider and a
data center of your choice. Additionally, you will have the option to select
from small, medium, or large resource packs, which can be scaled up or down
later as needed.

Before deploying the network, you will have the option to configure network
settings and customize the genesis file. For most use cases, it is recommended
to keep the default settings. Once configured, you can proceed with deployment.
After a few minutes, your network manager and first node will be fully
operational.

To enhance reliability, you should add more nodes to your network for fault
tolerance. The best practice is to deploy four validator nodes and two
non-validator nodes. Once the nodes are set up, adding a load balancer will help
distribute network traffic efficiently and improve performance.

Once your network, nodes, and load balancer are running, you can access the
Insights tab to integrate monitoring tools. For permissioned networks, you can
add Blockscout Blockchain Explorer to track transactions and network activity.
If you are using public EVM networks, publicly available blockchain explorers
can be used instead.

</div>
</div>

# Off-chain File Storage Use Cases in Blockchain Applications

Blockchain applications often require storing documents, images, videos, or
metadata off-chain due to cost, performance, or privacy reasons. Two common
approaches are:

- **IPFS**: A decentralized, content-addressed file system ideal for immutable,
  verifiable, and censorship-resistant data.
- **Amazon S3**: A centralized, enterprise-grade storage solution that supports
  private files, fine-grained access control, and fast retrieval.

Below are separate use case tables for each.

---

## üåê IPFS (InterPlanetary File System)

IPFS is a decentralized protocol for storing and sharing files in a peer-to-peer
network. Files are addressed by their content hash (CID), ensuring immutability
and verification.

| Category                   | Use Cases                                                                              |
| -------------------------- | -------------------------------------------------------------------------------------- |
| **NFTs & Metadata**        | NFT images and media, Metadata JSON, Reveal assets, Provenance data                    |
| **Decentralized Identity** | Hash of KYC documents, Verifiable credentials, DID documents, Encrypted identity data  |
| **DAOs & Governance**      | Proposals with supporting files, Community manifestos, Off-chain vote metadata         |
| **Public Records**         | Timestamped proofs, Open access research, Transparent regulatory disclosures           |
| **Content Publishing**     | Articles, Audio files, Podcasts, Open knowledge archives                               |
| **Gaming & Metaverse**     | 3D assets, Wearables, In-game items, IPFS-based map data                               |
| **Token Ecosystems**       | Whitepapers, Token metadata, Proof-of-reserve documents                                |
| **Data Integrity Proofs**  | Merkle tree files, Hashed content for audit, CID-linked validation                     |
| **Hybrid dApps**           | On-chain reference to CID, IPFS-pinned metadata, Public shareable URIs                 |
| **Data Portability**       | Decentralized content backups, Peer-to-peer file sharing, Long-term open data archives |

---

## ‚òÅÔ∏è Amazon S3 (Simple Storage Service)

Amazon S3 is a centralized cloud storage platform that offers speed,
scalability, and rich security features. It is especially suitable for private
or enterprise-grade applications.

| Category                      | Use Cases                                                                               |
| ----------------------------- | --------------------------------------------------------------------------------------- |
| **KYC / Identity Management** | Encrypted KYC files, ID document storage, Compliance scans, Signature uploads           |
| **User Uploads**              | Profile pictures, File attachments, Media uploads, Form attachments                     |
| **Admin Dashboards**          | Exported reports, Internal analytics files, Logs and snapshots                          |
| **E-Commerce / Marketplaces** | Product images, Order confirmations, Receipts, Invoices                                 |
| **Private DAO Ops**           | Budget spreadsheets, Voting records, Internal documents                                 |
| **Education Platforms**       | Certificates, Course PDFs, Student submissions                                          |
| **Customer Support**          | Ticket attachments, User-submitted evidence, File-based case history                    |
| **Real-Time Interfaces**      | UI asset delivery, Previews, Optimized media for front-end display                      |
| **Data Recovery**             | Automatic backups, Encrypted snapshots, Versioned file histories                        |
| **Secure Downloads**          | Signed URLs for restricted access, Expirable public links, S3-based token-gated content |

---

## Summary: When to Use Which?

| Use Case Pattern                      | Recommended Storage |
| ------------------------------------- | ------------------- |
| Public, immutable content             | **IPFS**            |
| Verifiable, on-chain linked data      | **IPFS**            |
| Private or role-based content         | **S3**              |
| Fast real-time access (UI/media)      | **S3**              |
| Hybrid (IPFS for hash, S3 for access) | **Both**            |

Each system has unique advantages. For truly decentralized applications where
transparency and verifiability matter, IPFS is a natural fit. For operational
scalability, secure access, and enterprise-grade needs, S3 provides a reliable
foundation.

In hybrid dApps, combining both ensures performance without compromising on
decentralization.

## Add Storage

<Tabs items={['Platform UI', 'SDK CLI', 'SDK JS']}>
  <Tab value="Platform UI">
    Navigate to the **application** where you want to add storage. Click **Storage** in the left navigation, and then click **Add storage**. This opens a form.

    <Steps>
      ### Configure Storage
      1. Choose storage type (IPFS or MinIO)
      2. Choose a **Storage name**
      3. Configure deployment settings
      4. Click **Confirm**
    </Steps>

  </Tab>

  <Tab value="SDK CLI">
    First ensure you're authenticated:
    ```bash
    settlemint login
    ```

    Create storage:
    ```bash
    # Get the list of available storage types
    settlemint platform create storage --help

    # Create storage
    settlemint platform create storage <type> <name>

    # Get information about the command and all available options
    settlemint platform create storage <type> --help
    ```

  </Tab>

  <Tab value="SDK JS">
    For a full example of how to connect to a storage using the SDK, see the [MinIO SDK API Reference](https://www.npmjs.com/package/@settlemint/sdk-minio#api-reference) or [IPFS SDK API Reference](https://www.npmjs.com/package/@settlemint/sdk-ipfs#api-reference).

    <Callout type="info">
    Get your access token from the Platform UI under User Settings ‚Üí API Tokens.
    </Callout>

    <Callout type="info">
    The SDK enables you to:
    - Use IPFS for decentralized storage - check out the [IPFS SDK documentation](https://github.com/settlemint/sdk/tree/main/sdk/ipfs)
    - Use MinIO for S3-compatible storage - check out the [MinIO SDK documentation](https://github.com/settlemint/sdk/tree/main/sdk/minio)
    </Callout>

  </Tab>
</Tabs>

## Manage Storage

<Tabs items={['Platform UI', 'SDK CLI', 'SDK JS']}>
  <Tab value="Platform UI">
    Navigate to your storage and click **Manage storage** to:
    - View storage details and status
    - Monitor health
    - Access storage interface
    - Update configurations
  </Tab>

  <Tab value="SDK CLI">
    ```bash
    # List storage instances
    settlemint platform list storage --application <app-name>

    # Get storage details
    settlemint platform read storage <name>

    # Delete storage
    settlemint platform delete storage <name>
    ```

  </Tab>

  <Tab value="SDK JS">
    ```typescript
    // List storage instances
    const listStorage = async () => {
      const storages = await client.storage.list("your-app-id");
      console.log('Storage instances:', storages);
    };

    // Get storage details
    const getStorage = async () => {
      const storage = await client.storage.read("storage-unique-name");
      console.log('Storage details:', storage);
    };

    // Delete storage
    const deleteStorage = async () => {
      await client.storage.delete("storage-unique-name");
    };
    ```

  </Tab>
</Tabs>
